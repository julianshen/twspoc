// store/notification_repo.go
package rethinkstore

import (
	"context"
	"fmt"
	"notification/notificationrepo"
	"notification/types"
	"sync"
	"time"

	r "github.com/rethinkdb/rethinkdb-go"
)

type rethinkRepo struct {
	session     *r.Session
	tableName   string
	mu          sync.Mutex
	subscribers map[string][]chan *types.Notification
}

func NewRethinkNotificationRepo(session *r.Session) notificationrepo.NotificationRepository {
	return &rethinkRepo{
		session:     session,
		tableName:   "notifications",
		subscribers: make(map[string][]chan *types.Notification),
	}
}

// Create inserts a new notification.
func (rdb *rethinkRepo) Create(ctx context.Context, n *types.Notification) error {
	n.Timestamp = time.Now()
	writeRes, err := r.Table(rdb.tableName).Insert(n).RunWrite(rdb.session, r.RunOpts{Context: ctx})
	if err != nil {
		return err
	}
	if writeRes.Inserted != 1 {
		return fmt.Errorf("expected 1 document inserted, got %d", writeRes.Inserted)
	}
	// Set the ID field if generated by RethinkDB
	if len(writeRes.GeneratedKeys) > 0 {
		n.ID = writeRes.GeneratedKeys[0]
	}
	return nil
}

// Get retrieves a notification by ID.
func (rdb *rethinkRepo) Get(ctx context.Context, id string) (*types.Notification, error) {
	cursor, err := r.Table(rdb.tableName).Get(id).Run(rdb.session, r.RunOpts{Context: ctx})
	if err != nil {
		return nil, err
	}
	defer cursor.Close()
	var n types.Notification
	if cursor.Next(&n) {
		return &n, nil
	}
	return nil, fmt.Errorf("notification not found")
}

// Update updates an existing notification (by ID).
func (rdb *rethinkRepo) Update(ctx context.Context, n *types.Notification) error {
	_, err := r.Table(rdb.tableName).Get(n.ID).Update(n).RunWrite(rdb.session, r.RunOpts{Context: ctx})
	return err
}

// Delete deletes a notification by ID.
func (rdb *rethinkRepo) Delete(ctx context.Context, id string) error {
	_, err := r.Table(rdb.tableName).Get(id).Delete().RunWrite(rdb.session, r.RunOpts{Context: ctx})
	return err
}

// ListByUser lists notifications for a user.
func (rdb *rethinkRepo) ListByUser(ctx context.Context, userID string) ([]*types.Notification, error) {
	cursor, err := r.Table(rdb.tableName).
		Filter(func(row r.Term) r.Term {
			return row.Field("recipients").Contains(func(rec r.Term) r.Term {
				return rec.Field("id").Eq(userID)
			}).And(
				row.Field("deletedFor").Default([]interface{}{}).Contains(userID).Not(),
			)
		}).
		Run(rdb.session, r.RunOpts{Context: ctx})
	if err != nil {
		return nil, err
	}
	defer cursor.Close()

	var results []*types.Notification
	for {
		var n types.Notification
		if cursor.Next(&n) {
			results = append(results, &n)
		} else {
			break
		}
	}
	return results, cursor.Err()
}

// Subscribe is a stub for now (not implemented).
func (rdb *rethinkRepo) Subscribe(ctx context.Context, userID string) (<-chan *types.Notification, error) {
	ch := make(chan *types.Notification)
	// Not implemented: would require changefeeds or polling.
	close(ch)
	return ch, nil
}
